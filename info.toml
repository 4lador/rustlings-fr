# The format version is an indicator of the compatibility of third-party exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of third-party
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """Bienvenue dans la version traduite de Rustlings."""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """Bravo ! J'espère que ces exercices vous auront été utiles."""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Tape `n` (pour 'next') afin de passer à l'exercice suivant.
Tu pourrais avoir besoin d'appuyer sur ENTRÉE après avoir tapé `n`."""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
Le compilateur nous informe que nous avons mal écrit le nom de la macro d'affichage (print macro). Il suggère une alternative."""

# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
Il manque le mot-clé `let` dans la déclaration de variable à l'intérieur de la fonction `main`."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
Le message du compilateur indique que Rust ne peut pas déduire le type de la variable `x` avec ce qui est actuellement écrit.

Que se passe-t-il si tu annotes la première ligne dans la fonction `main` avec un type?

Que se passe-t-il si tu donnes une valeur à `x`?

Que se passe-t-il si tu fais les deux?

Quel type devrait avoir `x`, de toute façon?

Et si `x` est du même type que `10`? Et s'il est d'un type différent?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
Dans cet exercice, nous avons créé une variable dans la fonction `main`, et nous essayons de l'utiliser à la ligne suivante, mais nous ne lui avons pas donné de valeur.

Nous ne pouvons pas afficher quelque chose qui n'existe pas ; essaie de donner une valeur à `x` !

C'est une erreur qui peut causer des bugs et qui est très facile à faire dans n'importe quel langage de programmation — heureusement, le compilateur Rust l'a détectée pour nous !"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
En Rust, les variables sont immuables par défaut. Mais ici, nous essayons d'assigner une valeur différente à `x` ! Il existe un mot-clé que nous pouvons utiliser pour rendre une liaison de variable mutable."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
Dans `variables4`, nous avons déjà appris comment rendre une variable immuable mutable en utilisant un mot-clé spécial. Malheureusement, cela ne nous aide pas beaucoup dans cet exercice car nous voulons assigner une valeur de type différent à une variable existante. Parfois, tu peux aussi vouloir réutiliser des noms de variables existants parce que tu convertis simplement des valeurs vers différents types comme dans cet exercice.
Heureusement, Rust a une solution puissante à ce problème : le 'Shadowing' (masquage) !
Tu peux en savoir plus sur le 'Masquage' dans la section 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#le-masquage
Essaie de résoudre cet exercice en utilisant cette technique."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
Nous connaissons les variables et la mutabilité, mais il existe un autre type important de variable disponible : les constantes.

Les constantes sont toujours immuables. Elles sont déclarées avec le mot-clé `const` au lieu de `let`.

Le type des constantes doit toujours être annoté.

Tu peux en savoir plus sur les constantes et les différences entre les variables et les constantes dans la section 'Les Constantes' du chapitre 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#les-constantes"""

# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
La fonction `main` appelle une fonction qui, selon le programme, devrait exister, mais cette fonction n'existe pas. Le programme s'attend à ce que cette fonction ait le nom `call_me`. Il s'attend également à ce que cette fonction ne prenne aucun argument et ne renvoie aucune valeur. Ça ressemble beaucoup à `main`, n'est-ce pas ?"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """
Rust exige que toutes les parties de la signature d'une fonction aient des annotations de type, mais `call_me` n'a pas d'annotation de type pour `num`."""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """
Cette fois, la *déclaration* de la fonction est correcte, mais il y a un problème à l'endroit où nous appelons la fonction."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """
Le message d'erreur pointe vers la fonction `sale_price` et indique qu'il attend un type après `->`. C'est là que devrait se trouver le type de retour de la fonction. Jette un coup d'œil à la fonction `is_even` pour voir un exemple !"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
C'est une erreur très courante qui peut être corrigée en supprimant un seul caractère. 
Elle se produit parce que Rust fait la distinction entre les expressions et les instructions :
Les expressions renvoient une valeur basée sur leur(s) opérande(s), tandis que les instructions renvoient simplement 
un type `()` qui se comporte comme `void` en C/C++.
Nous voulons renvoyer une valeur de type `i32` de la fonction `square`, mais
elle renvoie le type `()`.
Il existe deux solutions :
1. Ajouter le mot-clé `return` avant `num * num;`
2. Supprimer le point-virgule `;` après `num * num`"""

# IF

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
Il est possible de faire cela en une seule ligne si tu le souhaites !

Quelques exemples similaires dans d'autres langages :
- En C(++) ce serait : `a > b ? a : b`
- En Python ce serait : `a if a > b else b`

N'oublie pas qu'en Rust :
- La condition `if` n'a pas besoin d'être entourée de parenthèses
- Les conditionnels `if`/`else` sont des expressions
- Chaque condition est suivie d'un bloc `{}`"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
Pour cette première erreur de compilation, il est important, en Rust, que chaque bloc conditionnel retourne le même type !

Pour faire passer les tests, tu auras besoin de quelques conditions vérifiant différentes valeurs d'entrée. Lis les tests pour découvrir ce qu'ils attendent."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
En Rust, chaque *branche* d'une expression `if` doit retourner le même type de valeur.
Assure-toi que le type soit cohérent dans toutes les *branches*."""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "Pas d'indices cette fois-ci ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """
En Rust, une valeur booléenne peut être inversée en utilisant l'opérateur `!` placé devant.
Exemple : `!true == false`
Cela fonctionne également avec les variables booléennes."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
Il existe un raccourci pour initialiser des tableaux d'une certaine taille qui ne
te demande pas de saisir 100 éléments (mais tu peux certainement le faire si tu le souhaites !).
Par exemple, tu peux faire :
```
let array = ["On arrive bientôt ?"; 100];
```
Bonus : quelles autres choses pourrais-tu avoir qui retourneraient `true`
pour `a.len() >= 100` ?"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
Regarde la section 'Comprendre la propriété -> Slices -> Autres Slices' 
du rust book (fr) : https://jimskapt.github.io/rust-book-fr/ch04-03-slices.html et utilise les
indices de début et de fin (plus un) des éléments du tableau que tu souhaites
avoir dans la slice.
Si tu te demandes pourquoi le premier argument de `assert_eq!` n'a pas
d'esperluette pour une référence alors que le second argument est une référence, jette un œil
au chapitre sur la coercition du nomicon :
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Regarde la section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Particulièrement la partie sur la destructuration (avant-dernier exemple dans la section).
Tu auras besoin de créer un pattern pour lier `name` et `age` aux parties appropriées du tuple."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """
Bien que tu pourrais utiliser un `let` avec destructuration pour le tuple ici, essaie plutôt 
d'y accéder par indexation, comme expliqué dans le dernier exemple de la
section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Maintenant, tu as une nouvelle corde à ton arc !"""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
En Rust, il existe deux façons de définir un Vector (vecteur).
1. Une façon est d'utiliser la fonction `Vec::new()` pour créer un nouveau vecteur
   et le remplir avec la méthode `push()`.
2. La seconde façon est d'utiliser la macro `vec![]` et définir tes éléments
   à l'intérieur des crochets. Cette façon est plus simple quand tu connais exactement
   les valeurs initiales.
Consulte ce chapitre : https://jimskapt.github.io/rust-book-fr/ch08-01-vectors.html
du Rust book pour en savoir plus."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
Dans la première fonction, nous créons un vecteur vide et voulons y ajouter de nouveaux éléments.
Dans la deuxième fonction, nous mappons les valeurs de l'entrée et les collectons dans un vecteur.

Après avoir complété les deux fonctions, décide par toi-même quelle approche tu préfères.
Selon toi, quel est le modèle le plus couramment utilisé par les développeurs Rust ?"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """
Donc tu as l'erreur "cannot borrow `vec` as mutable, as it is not declared as
mutable" (impossible d'emprunter `vec` comme mutable, car il n'est pas déclaré comme
mutable) sur la ligne où nous ajoutons un élément au vecteur, n'est-ce pas ?

La solution consiste à ajouter un seul mot-clé, et ce n'est PAS sur
la ligne où nous faisons un ajout au vecteur (où se trouve l'erreur).

Essaie d'accéder à `vec0` après avoir appelé `fill_vec()`. Regarde ce qui se passe !"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
Quand tu exécutes cet exercice pour la première fois, tu remarqueras une erreur concernant
"borrow of moved value" (emprunt d'une valeur déplacée). En Rust, quand un argument est passé à une fonction et
qu'il n'est pas explicitement retourné, tu ne peux plus utiliser la variable originale.
On appelle cela "déplacer" (moving) une variable. Quand nous passons `vec0` dans `fill_vec`, elle est
"déplacée" dans `vec1`, ce qui signifie que nous ne pouvons plus accéder à `vec0`.

Tu pourrais créer une autre version séparée des données contenues dans `vec0` et
la passer à `fill_vec` à la place. Cela s'appelle cloning (clonage) en Rust."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """
La différence entre celui-ci et les précédents est que la première ligne
de `fn fill_vec` qui avait `let mut vec = vec;` n'est plus là. Tu peux,
au lieu de remettre cette ligne, ajouter `mut` à un endroit qui transformera
un binding (liaison) existant en binding mutable plutôt qu'immutable :)"""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Réfléchis attentivement à la portée (scope) dans laquelle chaque référence mutable est
active. Est-ce utile de mettre à jour la valeur de `x` immédiatement après
avoir pris la référence mutable ?
En savoir plus sur les 'Mutable References' (références mutables) dans la section 'References and Borrowing' du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-mutables"""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """
Pour trouver la réponse, tu peux consulter la section "References and Borrowing" du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html

Le premier problème est que `get_char` prend possession (ownership) de la chaîne. Donc
`data` est déplacée et ne peut pas être utilisée pour `string_uppercase`. `data` est d'abord déplacée vers
`get_char`, ce qui signifie que `string_uppercase` ne peut pas manipuler les données.

Une fois que tu auras résolu ce problème, la signature de la fonction `string_uppercase` devra également
être ajustée."""

# STRUCTS

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """
Rust possède plus d'un type de struct. Trois en fait, toutes les variantes sont utilisées pour 
regrouper des données liées.

Il y a les structs régulières. Ce sont des collections nommées de données liées stockées dans 
des fields (champs).

Les tuple structs sont essentiellement des tuples nommés.

Enfin, les unit structs. Elles n'ont pas de champs et sont utiles pour les generics (génériques).

Dans cet exercice, tu dois compléter et implémenter un exemple de chaque type.
Pour en savoir plus sur les structs, consulte le rust book :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """
Créer des instances de structs est facile, il suffit d'assigner des valeurs 
à ses fields (champs).

Il existe cependant quelques raccourcis qui peuvent être utilisés lors de l'instanciation des structs.
Jette un œil au rust book pour en savoir plus :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
Pour `is_international` : Qu'est-ce qui rend un colis international ? Cela semble lié 
aux endroits par lesquels il passe, n'est-ce pas ?

Pour `get_fees` : Cette méthode prend un argument supplémentaire, y a-t-il un field (champ) dans 
la struct `Package` auquel cela se rapporte ?

Consulte le rust book pour en savoir plus sur les implémentations de méthodes :
https://jimskapt.github.io/rust-book-fr/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
Tu peux créer des énumérations qui ont différentes variantes avec différents types tels que des structs anonymes, des structs, une simple string (chaîne de caractères), des tuples, sans données, etc."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """
Commence par définir des énumérations pour compiler le code sans erreurs.

Ensuite, crée une expression match dans `process()`.

Note que tu dois déconstruire certaines variantes du message dans l'expression match pour obtenir les valeurs de la variante."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
La fonction `current_favorite_color` renvoie actuellement un string slice (tranche de chaîne de caractères) avec la durée de vie `'static`. Nous le savons parce que les données de la chaîne existent directement dans notre code -- elles ne proviennent pas d'un fichier, d'une saisie utilisateur ou d'un autre programme -- donc elles vivront aussi longtemps que notre programme.

Mais c'est toujours un string slice. Il existe une façon de créer un `String` en convertissant un string slice, comme expliqué dans le chapitre sur les Strings du rust book, et une autre méthode qui utilise le trait `From`.
https://jimskapt.github.io/rust-book-fr/ch08-02-strings.html"""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Oui, ce serait vraiment facile de corriger cela en changeant simplement la valeur liée à `word` pour qu'elle soit un string slice (tranche de chaîne) au lieu d'un `String`, n'est-ce pas ? Il existe cependant une façon d'ajouter un seul caractère à l'instruction `if` qui permettra de contraindre le `String` en un string slice.

Note : Si tu es intéressé(e) par comprendre comment fonctionne ce type de conversion de référence, tu peux avancer dans le rust book et lire cette partie dans le chapitre sur les smart pointers (pointeurs intelligents) :
https://jimskapt.github.io/rust-book-fr/ch15-02-deref.html#extrapolation-de-d%C3%A9r%C3%A9f%C3%A9rencement-implicite-avec-les-fonctions-et-les-m%C3%A9thodes"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """
Il existe de nombreuses fonctions utiles dans la bibliothèque standard pour les strings (chaînes de caractères). Essayons d'en utiliser quelques-unes :
https://doc.rust-lang.org/std/string/struct.String.html#method.trim

Pour la méthode `compose_me` : Tu peux soit utiliser la macro `format!`, soit convertir la tranche de chaîne en une chaîne possédée, que tu pourras ensuite étendre librement.

Pour la méthode `replace_me`, tu peux consulter la méthode `replace` :
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Remplace `placeholder` par `string` ou `string_slice` dans la fonction `main`.

Exemple :
`placeholder("blue");`
doit devenir
`string_slice("blue");`
car "blue" est un `&str`, pas un `String`."""

# MODULES

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """
Tout est privé par défaut en Rust. Mais il existe un mot-clé qu'on peut utiliser pour rendre quelque chose public !"""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """
Le module `delicious_snacks` essaie de présenter une interface externe différente de sa structure interne (les modules `fruits` et `veggies` et leurs constantes associées). Complète les déclarations `use` pour correspondre aux utilisations dans `main` et trouve le mot-clé manquant pour les deux constantes.

Pour en savoir plus dans le rust book:
https://jimskapt.github.io/rust-book-fr/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#r%C3%A9exporter-des-%C3%A9l%C3%A9ments-avec-pub-use"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """
`UNIX_EPOCH` et `SystemTime` sont déclarés dans le module `std::time`. Ajoute une déclaration `use` pour ces deux éléments afin de les intégrer dans la portée. Tu peux utiliser des chemins imbriqués pour les importer en une seule ligne."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """
Le nombre de fruits devrait être au moins 5 et tu dois inclure au moins 3
types différents de fruits."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """
Utilise les méthodes `entry()` et `or_insert()` de `HashMap` pour accomplir cela.

Pour en savoir plus, renvez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#ajouter-une-valeur-seulement-si-la-cl%C3%A9-na-pas-d%C3%A9j%C3%A0-de-valeur"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """
Indice 1 : Utilise les méthodes `entry()` et `or_default()` de `HashMap` pour insérer la
       valeur par défaut de `TeamScores` si une équipe n'existe pas encore dans la table.

Indice 2 : S'il existe déjà une entrée pour une clé donnée, la valeur renvoyée par
       `entry()` peut être mise à jour en fonction de la valeur existante.

Pour en savoir plus, rendez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#modifier-une-valeur-en-fonction-de-lancienne-valeur"""

# QUIZ 2

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = "The `+` operator can concatenate a `String` with a `&str`."

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Options can have a `Some` value, with an inner value, or a `None` value,
without an inner value.

There are multiple ways to get at the inner value, you can use `unwrap`, or
pattern match. Unwrapping is the easiest, but how do you do it safely so that
it doesn't panic in your face later?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """
Check out:

- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

Remember that `Option`s can be nested in if-let and while-let statements.

For example: `if let Some(Some(x)) = y`

Also see `Option::flatten`"""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """
The compiler says a partial move happened in the `match` statement. How can
this be avoided? The compiler shows the correction needed.

After making the correction as suggested by the compiler, read the related docs
page:
https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """
`Ok` and `Err` are the two variants of `Result`, so what the tests are saying
is that `generate_nametag_text` should return a `Result` instead of an `Option`.

To make this change, you'll need to:
  - update the return type in the function signature to be a `Result<String,
    String>` that could be the variants `Ok(String)` and `Err(String)`
  - change the body of the function to return `Ok(…)` where it currently
    returns `Some(…)`
  - change the body of the function to return `Err(error message)` where it
    currently returns `None`"""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """
One way to handle this is using a `match` statement on
`item_quantity.parse::<i32>()` where the cases are `Ok(something)` and
`Err(something)`.

This pattern is very common in Rust, though, so there's the `?` operator that
does pretty much what you would make that match statement do for you!

Take a look at this section of the "Error Handling" chapter:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """
If other functions can return a `Result`, why shouldn't `main`? It's a fairly
common convention to return something like `Result<(), ErrorType>` from your
`main` function.

The unit type `()` is there because nothing is really needed in terms of a
positive result."""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """
`PositiveNonzeroInteger::new` is always creating a new instance and returning
an `Ok` result. But it should be doing some checking, returning an `Err` if
those checks fail, and only returning an `Ok` if those checks determine that
everything is… okay :)"""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """
There are two different 
