# The format version is an indicator of the compatibility of third-party exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of third-party
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """Bienvenue dans la version traduite de Rustlings."""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """Bravo ! J'espère que ces exercices vous auront été utiles."""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Tape `n` (pour 'next') afin de passer à l'exercice suivant.
Tu pourrais avoir besoin d'appuyer sur ENTRÉE après avoir tapé `n`."""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
Le compilateur nous informe que nous avons mal écrit le nom de la macro d'affichage (print macro). Il suggère une alternative."""

# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
Il manque le mot-clé `let` dans la déclaration de variable à l'intérieur de la fonction `main`."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
Le message du compilateur indique que Rust ne peut pas déduire le type de la variable `x` avec ce qui est actuellement écrit.

Que se passe-t-il si tu annotes la première ligne dans la fonction `main` avec un type?

Que se passe-t-il si tu donnes une valeur à `x`?

Que se passe-t-il si tu fais les deux?

Quel type devrait avoir `x`, de toute façon?

Et si `x` est du même type que `10`? Et s'il est d'un type différent?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
Dans cet exercice, nous avons créé une variable dans la fonction `main`, et nous essayons de l'utiliser à la ligne suivante, mais nous ne lui avons pas donné de valeur.

Nous ne pouvons pas afficher quelque chose qui n'existe pas ; essaie de donner une valeur à `x` !

C'est une erreur qui peut causer des bugs et qui est très facile à faire dans n'importe quel langage de programmation — heureusement, le compilateur Rust l'a détectée pour nous !"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
En Rust, les variables sont immuables par défaut. Mais ici, nous essayons d'assigner une valeur différente à `x` ! Il existe un mot-clé que nous pouvons utiliser pour rendre une liaison de variable mutable."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
Dans `variables4`, nous avons déjà appris comment rendre une variable immuable mutable en utilisant un mot-clé spécial. Malheureusement, cela ne nous aide pas beaucoup dans cet exercice car nous voulons assigner une valeur de type différent à une variable existante. Parfois, tu peux aussi vouloir réutiliser des noms de variables existants parce que tu convertis simplement des valeurs vers différents types comme dans cet exercice.
Heureusement, Rust a une solution puissante à ce problème : le 'Shadowing' (masquage) !
Tu peux en savoir plus sur le 'Masquage' dans la section 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#le-masquage
Essaie de résoudre cet exercice en utilisant cette technique."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
Nous connaissons les variables et la mutabilité, mais il existe un autre type important de variable disponible : les constantes.

Les constantes sont toujours immuables. Elles sont déclarées avec le mot-clé `const` au lieu de `let`.

Le type des constantes doit toujours être annoté.

Tu peux en savoir plus sur les constantes et les différences entre les variables et les constantes dans la section 'Les Constantes' du chapitre 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#les-constantes"""

# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
La fonction `main` appelle une fonction qui, selon le programme, devrait exister, mais cette fonction n'existe pas. Le programme s'attend à ce que cette fonction ait le nom `call_me`. Il s'attend également à ce que cette fonction ne prenne aucun argument et ne renvoie aucune valeur. Ça ressemble beaucoup à `main`, n'est-ce pas ?"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """
Rust exige que toutes les parties de la signature d'une fonction aient des annotations de type, mais `call_me` n'a pas d'annotation de type pour `num`."""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """
Cette fois, la *déclaration* de la fonction est correcte, mais il y a un problème à l'endroit où nous appelons la fonction."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """
Le message d'erreur pointe vers la fonction `sale_price` et indique qu'il attend un type après `->`. C'est là que devrait se trouver le type de retour de la fonction. Jette un coup d'œil à la fonction `is_even` pour voir un exemple !"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
C'est une erreur très courante qui peut être corrigée en supprimant un seul caractère. 
Elle se produit parce que Rust fait la distinction entre les expressions et les instructions :
Les expressions renvoient une valeur basée sur leur(s) opérande(s), tandis que les instructions renvoient simplement 
un type `()` qui se comporte comme `void` en C/C++.
Nous voulons renvoyer une valeur de type `i32` de la fonction `square`, mais
elle renvoie le type `()`.
Il existe deux solutions :
1. Ajouter le mot-clé `return` avant `num * num;`
2. Supprimer le point-virgule `;` après `num * num`"""

# IF

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
Il est possible de faire cela en une seule ligne si tu le souhaites !

Quelques exemples similaires dans d'autres langages :
- En C(++) ce serait : `a > b ? a : b`
- En Python ce serait : `a if a > b else b`

N'oublie pas qu'en Rust :
- La condition `if` n'a pas besoin d'être entourée de parenthèses
- Les conditionnels `if`/`else` sont des expressions
- Chaque condition est suivie d'un bloc `{}`"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
Pour cette première erreur de compilation, il est important, en Rust, que chaque bloc conditionnel retourne le même type !

Pour faire passer les tests, tu auras besoin de quelques conditions vérifiant différentes valeurs d'entrée. Lis les tests pour découvrir ce qu'ils attendent."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
En Rust, chaque *branche* d'une expression `if` doit retourner le même type de valeur.
Assure-toi que le type soit cohérent dans toutes les *branches*."""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "Pas d'indices cette fois-ci ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """
En Rust, une valeur booléenne peut être inversée en utilisant l'opérateur `!` placé devant.
Exemple : `!true == false`
Cela fonctionne également avec les variables booléennes."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
Il existe un raccourci pour initialiser des tableaux d'une certaine taille qui ne
te demande pas de saisir 100 éléments (mais tu peux certainement le faire si tu le souhaites !).
Par exemple, tu peux faire :
```
let array = ["On arrive bientôt ?"; 100];
```
Bonus : quelles autres choses pourrais-tu avoir qui retourneraient `true`
pour `a.len() >= 100` ?"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
Regarde la section 'Comprendre la propriété -> Slices -> Autres Slices' 
du rust book (fr) : https://jimskapt.github.io/rust-book-fr/ch04-03-slices.html et utilise les
indices de début et de fin (plus un) des éléments du tableau que tu souhaites
avoir dans la slice.
Si tu te demandes pourquoi le premier argument de `assert_eq!` n'a pas
d'esperluette pour une référence alors que le second argument est une référence, jette un œil
au chapitre sur la coercition du nomicon :
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Regarde la section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Particulièrement la partie sur la destructuration (avant-dernier exemple dans la section).
Tu auras besoin de créer un pattern pour lier `name` et `age` aux parties appropriées du tuple."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """
Bien que tu pourrais utiliser un `let` avec destructuration pour le tuple ici, essaie plutôt 
d'y accéder par indexation, comme expliqué dans le dernier exemple de la
section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Maintenant, tu as une nouvelle corde à ton arc !"""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
En Rust, il existe deux façons de définir un Vector (vecteur).
1. Une façon est d'utiliser la fonction `Vec::new()` pour créer un nouveau vecteur
   et le remplir avec la méthode `push()`.
2. La seconde façon est d'utiliser la macro `vec![]` et définir tes éléments
   à l'intérieur des crochets. Cette façon est plus simple quand tu connais exactement
   les valeurs initiales.
Consulte ce chapitre : https://jimskapt.github.io/rust-book-fr/ch08-01-vectors.html
du Rust book pour en savoir plus."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
Dans la première fonction, nous créons un vecteur vide et voulons y ajouter de nouveaux éléments.
Dans la deuxième fonction, nous mappons les valeurs de l'entrée et les collectons dans un vecteur.

Après avoir complété les deux fonctions, décide par toi-même quelle approche tu préfères.
Selon toi, quel est le modèle le plus couramment utilisé par les développeurs Rust ?"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """
Donc tu as l'erreur "cannot borrow `vec` as mutable, as it is not declared as
mutable" (impossible d'emprunter `vec` comme mutable, car il n'est pas déclaré comme
mutable) sur la ligne où nous ajoutons un élément au vecteur, n'est-ce pas ?

La solution consiste à ajouter un seul mot-clé, et ce n'est PAS sur
la ligne où nous faisons un ajout au vecteur (où se trouve l'erreur).

Essaie d'accéder à `vec0` après avoir appelé `fill_vec()`. Regarde ce qui se passe !"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
Quand tu exécutes cet exercice pour la première fois, tu remarqueras une erreur concernant
"borrow of moved value" (emprunt d'une valeur déplacée). En Rust, quand un argument est passé à une fonction et
qu'il n'est pas explicitement retourné, tu ne peux plus utiliser la variable originale.
On appelle cela "déplacer" (moving) une variable. Quand nous passons `vec0` dans `fill_vec`, elle est
"déplacée" dans `vec1`, ce qui signifie que nous ne pouvons plus accéder à `vec0`.

Tu pourrais créer une autre version séparée des données contenues dans `vec0` et
la passer à `fill_vec` à la place. Cela s'appelle cloning (clonage) en Rust."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """
La différence entre celui-ci et les précédents est que la première ligne
de `fn fill_vec` qui avait `let mut vec = vec;` n'est plus là. Tu peux,
au lieu de remettre cette ligne, ajouter `mut` à un endroit qui transformera
un binding (liaison) existant en binding mutable plutôt qu'immutable :)"""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Réfléchis attentivement à la portée (scope) dans laquelle chaque référence mutable est
active. Est-ce utile de mettre à jour la valeur de `x` immédiatement après
avoir pris la référence mutable ?
En savoir plus sur les 'Mutable References' (références mutables) dans la section 'References and Borrowing' du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-mutables"""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """
Pour trouver la réponse, tu peux consulter la section "References and Borrowing" du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html

Le premier problème est que `get_char` prend possession (ownership) de la chaîne. Donc
`data` est déplacée et ne peut pas être utilisée pour `string_uppercase`. `data` est d'abord déplacée vers
`get_char`, ce qui signifie que `string_uppercase` ne peut pas manipuler les données.

Une fois que tu auras résolu ce problème, la signature de la fonction `string_uppercase` devra également
être ajustée."""

# STRUCTS

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """
Rust possède plus d'un type de struct. Trois en fait, toutes les variantes sont utilisées pour 
regrouper des données liées.

Il y a les structs régulières. Ce sont des collections nommées de données liées stockées dans 
des fields (champs).

Les tuple structs sont essentiellement des tuples nommés.

Enfin, les unit structs. Elles n'ont pas de champs et sont utiles pour les generics (génériques).

Dans cet exercice, tu dois compléter et implémenter un exemple de chaque type.
Pour en savoir plus sur les structs, consulte le rust book :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """
Créer des instances de structs est facile, il suffit d'assigner des valeurs 
à ses fields (champs).

Il existe cependant quelques raccourcis qui peuvent être utilisés lors de l'instanciation des structs.
Jette un œil au rust book pour en savoir plus :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
Pour `is_international` : Qu'est-ce qui rend un colis international ? Cela semble lié 
aux endroits par lesquels il passe, n'est-ce pas ?

Pour `get_fees` : Cette méthode prend un argument supplémentaire, y a-t-il un field (champ) dans 
la struct `Package` auquel cela se rapporte ?

Consulte le rust book pour en savoir plus sur les implémentations de méthodes :
https://jimskapt.github.io/rust-book-fr/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
Tu peux créer des énumérations qui ont différentes variantes avec différents types tels que des structs anonymes, des structs, une simple string (chaîne de caractères), des tuples, sans données, etc."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """
Commence par définir des énumérations pour compiler le code sans erreurs.

Ensuite, crée une expression match dans `process()`.

Note que tu dois déconstruire certaines variantes du message dans l'expression match pour obtenir les valeurs de la variante."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
La fonction `current_favorite_color` renvoie actuellement un string slice (tranche de chaîne de caractères) avec la durée de vie `'static`. Nous le savons parce que les données de la chaîne existent directement dans notre code -- elles ne proviennent pas d'un fichier, d'une saisie utilisateur ou d'un autre programme -- donc elles vivront aussi longtemps que notre programme.

Mais c'est toujours un string slice. Il existe une façon de créer un `String` en convertissant un string slice, comme expliqué dans le chapitre sur les Strings du rust book, et une autre méthode qui utilise le trait `From`.
https://jimskapt.github.io/rust-book-fr/ch08-02-strings.html"""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Oui, ce serait vraiment facile de corriger cela en changeant simplement la valeur liée à `word` pour qu'elle soit un string slice (tranche de chaîne) au lieu d'un `String`, n'est-ce pas ? Il existe cependant une façon d'ajouter un seul caractère à l'instruction `if` qui permettra de contraindre le `String` en un string slice.

Note : Si tu es intéressé(e) par comprendre comment fonctionne ce type de conversion de référence, tu peux avancer dans le rust book et lire cette partie dans le chapitre sur les smart pointers (pointeurs intelligents) :
https://jimskapt.github.io/rust-book-fr/ch15-02-deref.html#extrapolation-de-d%C3%A9r%C3%A9f%C3%A9rencement-implicite-avec-les-fonctions-et-les-m%C3%A9thodes"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """
Il existe de nombreuses fonctions utiles dans la bibliothèque standard pour les strings (chaînes de caractères). Essayons d'en utiliser quelques-unes :
https://doc.rust-lang.org/std/string/struct.String.html#method.trim

Pour la méthode `compose_me` : Tu peux soit utiliser la macro `format!`, soit convertir la tranche de chaîne en une chaîne possédée, que tu pourras ensuite étendre librement.

Pour la méthode `replace_me`, tu peux consulter la méthode `replace` :
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Remplace `placeholder` par `string` ou `string_slice` dans la fonction `main`.

Exemple :
`placeholder("blue");`
doit devenir
`string_slice("blue");`
car "blue" est un `&str`, pas un `String`."""

# MODULES

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """
Tout est privé par défaut en Rust. Mais il existe un mot-clé qu'on peut utiliser pour rendre quelque chose public !"""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """
Le module `delicious_snacks` essaie de présenter une interface externe différente de sa structure interne (les modules `fruits` et `veggies` et leurs constantes associées). Complète les déclarations `use` pour correspondre aux utilisations dans `main` et trouve le mot-clé manquant pour les deux constantes.

Pour en savoir plus dans le rust book:
https://jimskapt.github.io/rust-book-fr/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#r%C3%A9exporter-des-%C3%A9l%C3%A9ments-avec-pub-use"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """
`UNIX_EPOCH` et `SystemTime` sont déclarés dans le module `std::time`. Ajoute une déclaration `use` pour ces deux éléments afin de les intégrer dans la portée. Tu peux utiliser des chemins imbriqués pour les importer en une seule ligne."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """
Le nombre de fruits devrait être au moins 5 et tu dois inclure au moins 3
types différents de fruits."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """
Utilise les méthodes `entry()` et `or_insert()` de `HashMap` pour accomplir cela.

Pour en savoir plus, renvez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#ajouter-une-valeur-seulement-si-la-cl%C3%A9-na-pas-d%C3%A9j%C3%A0-de-valeur"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """
Indice 1 : Utilise les méthodes `entry()` et `or_default()` de `HashMap` pour insérer la
       valeur par défaut de `TeamScores` si une équipe n'existe pas encore dans la table.

Indice 2 : S'il existe déjà une entrée pour une clé donnée, la valeur renvoyée par
       `entry()` peut être mise à jour en fonction de la valeur existante.

Pour en savoir plus, rendez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#modifier-une-valeur-en-fonction-de-lancienne-valeur"""

# QUIZ 2

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = "L'opérateur `+` peut concaténer une `String` avec un `&str` (string slice)."

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Les Options peuvent avoir une valeur `Some`, avec une valeur interne, ou une valeur `None`, sans valeur interne.

Il existe plusieurs façons d'accéder à la valeur interne, tu peux utiliser `unwrap`, ou faire du pattern matching (filtrage par motif). Unwrap est le plus simple, mais comment le faire en toute sécurité pour éviter que ton programme ne panique plus tard ?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """
Jette un œil à :

- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

N'oublie pas que les `Option` peuvent être imbriquées dans les expressions if-let et while-let.

Par exemple : `if let Some(Some(x)) = y`

Voir aussi `Option::flatten`"""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """
Le compilateur indique qu'un déplacement partiel (partial move) s'est produit dans l'instruction `match`. Comment éviter cela ? Le compilateur montre la correction nécessaire.

Après avoir effectué la correction suggérée par le compilateur, lis la page de documentation associée :
https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """
`Ok` et `Err` sont les deux variantes de `Result`, donc ce que les tests demandent, 
c'est que `generate_nametag_text` renvoie un `Result` au lieu d'un `Option`.

Pour effectuer cette modification, tu devras :
  - mettre à jour le type de retour dans la signature de la fonction pour qu'il soit un `Result<String, 
    String>` qui pourrait avoir les variantes `Ok(String)` et `Err(String)`
  - modifier le corps de la fonction pour renvoyer `Ok(…)` là où il 
    renvoie actuellement `Some(…)`
  - modifier le corps de la fonction pour renvoyer `Err(message d'erreur)` là où il
    renvoie actuellement `None`"""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """
Une façon de gérer cela est d'utiliser une instruction `match` sur
`item_quantity.parse::<i32>()` où les cas sont `Ok(something)` et
`Err(something)`.

Ce modèle est très courant en Rust, donc il existe l'opérateur `?` qui
fait pratiquement ce que tu ferais avec cette instruction match !

Jette un œil à cette section du chapitre "Error Handling" (Gestion des erreurs) :
https://jimskapt.github.io/rust-book-fr/ch09-02-recoverable-errors-with-result.html#un-raccourci-pour-propager-les-erreurs--lop%C3%A9rateur-"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """
Si d'autres fonctions peuvent renvoyer un `Result` (résultat), pourquoi `main` ne le pourrait-il pas ? C'est une convention assez courante de renvoyer quelque chose comme `Result<(), TypeErreur>` depuis ta fonction `main`.

Le type unitaire `()` est là car rien n'est vraiment nécessaire en termes de résultat positif."""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """
La méthode `PositiveNonzeroInteger::new` crée toujours une nouvelle instance et renvoie un résultat `Ok`. Mais elle devrait effectuer des vérifications, renvoyer un `Err` si ces vérifications échouent, et ne renvoyer un `Ok` que si ces vérifications déterminent que tout est… correct :)"""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """
Il existe deux types de `Result` différents produits au sein de la fonction `main`, qui sont propagés à l'aide des opérateurs `?`. Comment déclarer un type de retour pour la fonction `main` qui permette les deux ?

En coulisses, l'opérateur `?` appelle `From::from` sur la valeur d'erreur pour la convertir en un objet de trait boîté (trait object), un `Box<dyn Error>`. Cet objet de trait boîté est polymorphique, et comme toutes les erreurs implémentent le trait `Error`, on peut capturer de nombreuses erreurs différentes dans un seul objet `Box`.

Consulte cette section du Livre :
https://jimskapt.github.io/rust-book-fr/ch09-02-recoverable-errors-with-result.html#un-raccourci-pour-propager-les-erreurs--lop%C3%A9rateur-

Lis plus sur le boxing des erreurs :
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Lis plus sur l'utilisation de l'opérateur `?` avec des erreurs boîtées :
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "errors6"
dir = "13_error_handling"
hint = """
Cet exercice utilise une version complétée de `PositiveNonzeroInteger` des exercices précédents.

Sous la ligne où `TODO` te demande de faire une modification, il y a un exemple d'utilisation de la méthode `map_err()` sur un `Result` pour transformer un type d'erreur en un autre. Essaie d'utiliser quelque chose de similaire sur le `Result` de `parse()`. Tu pourras ensuite utiliser l'opérateur `?` pour un retour anticipé.

Plus d'info sur `map_err()` dans la documentation `std::result` :
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
dir = "14_generics"
test = false
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any
type.
If the vector `numbers` has the type `Vec<T>`, then we can only push values of
type `T` to it. By using `into()` before pushing, we ask the compiler to convert
`n1` and `n2` to `T`. But the compiler doesn't know what `T` is yet and needs a
type annotation.

`u8` and `i8` can both be converted to `i16`, `i32` and `i64`. Choose one for
the generic of the vector."""

[[exercises]]
name = "generics2"
dir = "14_generics"
hint = """
Related section in The Book:
https://doc.rust-lang.org/book/ch10-01-syntax.html#in-method-definitions"""

# TRAITS

[[exercises]]
name = "traits1"
dir = "15_traits"
hint = """
More about traits in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html

The `+` operator can concatenate a `String` with a `&str`."""

[[exercises]]
name = "traits2"
dir = "15_traits"
hint = """
Notice how the trait takes ownership of `self` and returns `Self`.

Although the signature of `append_bar` in the trait takes `self` as argument,
the implementation can take `mut self` instead. This is possible because the
the value is owned anyway."""

[[exercises]]
name = "traits3"
dir = "15_traits"
hint = """
Traits can have a default implementation for functions. Data types that
implement the trait can then use the default version of these functions
if they choose not to implement the function themselves.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations"""

[[exercises]]
name = "traits4"
dir = "15_traits"
hint = """
Instead of using concrete types as parameters you can use traits. Try replacing
`???` with `impl [what goes here?]`.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"""

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try
replacing `???` with 'impl [what goes here?] + [what goes here?]'.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax"""

# QUIZ 3

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """
To find the best solution to this challenge, you need to recall your knowledge
of traits, specifically "Trait Bound Syntax":
https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bound-syntax

Here is how to specify a trait bound for an implementation block:
`impl<T: Trait1 + Trait2 + …> for Foo<T> { … }`

You may need this:
`use std::fmt::Display;`"""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
dir = "16_lifetimes"
hint = """
Let the compiler guide you. Also take a look at The Book if you need help:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
dir = "16_lifetimes"
test = false
hint = """
Remember that the generic lifetime `'a` will get the concrete lifetime that is
equal to the smaller of the lifetimes of `x` and `y`.

You can take at least two paths to achieve the desired result while keeping the
inner block:
1. Move the `string2` declaration to make it live as long as `string1` (how is
   `result` declared?)
2. Move `println!` into the inner block"""

[[exercises]]
name = "lifetimes3"
dir = "16_lifetimes"
test = false
hint = """Let the compiler guide you :)"""

# TESTS

[[exercises]]
name = "tests1"
dir = "17_tests"
hint = """
`assert!` is a macro that needs an argument. Depending on the value of the
argument, `assert!` will do nothing (in which case the test will pass) or
`assert!` will panic (in which case the test will fail).

So try giving different values to `assert!` and see which ones compile, which
ones pass, and which ones fail :)

If you want to check for `false`, you can negate the result of what you're
checking using `!`, like `assert!(!…)`."""

[[exercises]]
name = "tests2"
dir = "17_tests"
hint = """
`assert_eq!` is a macro that takes two arguments and compares them. Try giving
it two values that are equal! Try giving it two arguments that are different!
Try switching which argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
dir = "17_tests"
hint = """
We expect the method `Rectangle::new` to panic for negative values.

To handle that, you need to add a special attribute to the test function.

You can refer to the docs:
https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
dir = "18_iterators"
hint = """
An iterator goes through all elements in a collection, but what if we've run
out of elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html"""

[[exercises]]
name = "iterators2"
dir = "18_iterators"
hint = """
`capitalize_first`:

The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `chars` in order to return the correct `String`.

The remaining characters in `chars` can be viewed as a string slice using the
`as_str` method.

The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Use `char::to_uppercase`. It returns an iterator that can be converted to a
`String`.

`capitalize_words_vector`:

Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to `collect` the iterator.

`capitalize_words_string`:

This is surprisingly similar to the previous solution. `collect` is very
powerful and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
dir = "18_iterators"
hint = """
The `divide` function needs to return the correct error when the divisor is 0 or
when even division is not possible.

The `division_results` variable needs to be collected into a collection type.

The `result_with_list` function needs to return a single `Result` where the
success case is a vector of integers and the failure case is a `DivisionError`.

The `list_of_results` function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for
how the `FromIterator` trait is used in `collect()`. This trait is REALLY
powerful! It can make the solution to this exercise much easier."""

[[exercises]]
name = "iterators4"
dir = "18_iterators"
hint = """
In an imperative language, you might write a `for` loop that updates a mutable
variable. Or, you might write code utilizing recursion and a match clause. In
Rust, you can take another functional approach, computing the factorial
elegantly with ranges and iterators.

Check out the `fold` and `rfold` methods!"""

[[exercises]]
name = "iterators5"
dir = "18_iterators"
hint = """
The documentation for the `std::iter::Iterator` trait contains numerous methods
that would be helpful here.

The `collection` variable in `count_collection_iterator` is a slice of
`HashMap`s. It needs to be converted into an iterator in order to use the
iterator methods.

The `fold` method can be useful in the `count_collection_iterator` function.

For a further challenge, consult the documentation for `Iterator` to find
a different method that could make your code more compact than using `fold`."""

# SMART POINTERS

[[exercises]]
name = "box1"
dir = "19_smart_pointers"
hint = """
The compiler's message should help: Since we cannot store the value of the
actual type when working with recursive types, we need to store a reference
(pointer) to its value.

We should, therefore, place our `List` inside a `Box`. More details in The Book:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Creating an empty list should be fairly straightforward (Hint: Read the tests).

For a non-empty list, keep in mind that we want to use our `Cons` list builder.
Although the current list is one of integers (`i32`), feel free to change the
definition and try other types!"""

[[exercises]]
name = "rc1"
dir = "19_smart_pointers"
hint = """
This is a straightforward exercise to use the `Rc<T>` type. Each `Planet` has
ownership of the `Sun`, and uses `Rc::clone()` to increment the reference count
of the `Sun`.

After using `drop()` to move the `Planet`s out of scope individually, the
reference count goes down.

In the end, the `Sun` only has one reference again, to itself.

See more at: https://doc.rust-lang.org/book/ch15-04-rc.html

Unfortunately, Pluto is no longer considered a planet :("""

[[exercises]]
name = "arc1"
dir = "19_smart_pointers"
test = false
hint = """
Make `shared_numbers` be an `Arc` from the `numbers` vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the `Arc` of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in The
Book:
https://doc.rust-lang.org/book/ch16-00-concurrency.html"""

[[exercises]]
name = "cow1"
dir = "19_smart_pointers"
hint = """
If `Cow` already owns the data, it doesn't need to clone it when `to_mut()` is
called.

Check out the documentation of the `Cow` type:
https://doc.rust-lang.org/std/borrow/enum.Cow.html"""

# THREADS

[[exercises]]
name = "threads1"
dir = "20_threads"
test = false
hint = """
`JoinHandle` is a struct that is returned from a spawned thread:
https://doc.rust-lang.org/std/thread/fn.spawn.html

A challenge with multi-threaded applications is that the main thread can
finish before the spawned threads are done.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Use the `JoinHandle`s to wait for each thread to finish and collect their
results.

https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"""

[[exercises]]
name = "threads2"
dir = "20_threads"
test = false
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_done` so
we'll need to also use another type that will only allow one thread to mutate
the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct

Keep reading if you'd like more hints :)

Do you now have an `Arc<Mutex<JobStatus>>` at the beginning of `main`? Like:
```
let status = Arc::new(Mutex::new(JobStatus { jobs_done: 0 }));
```

Similar to the code in the following example in The Book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads"""

[[exercises]]
name = "threads3"
dir = "20_threads"
hint = """
An alternate way to handle concurrency between threads is to use an `mpsc`
(multiple producer, single consumer) channel to communicate.

With both a sending end and a receiving end, it's possible to send values in
one thread and receive them in another.

Multiple producers are possible by using `clone()` to create a duplicate of the
original sending end.

Related section in The Book:
https://doc.rust-lang.org/book/ch16-02-message-passing.html"""

# MACROS

[[exercises]]
name = "macros1"
dir = "21_macros"
test = false
hint = """
When you call a macro, you need to add something special compared to a regular
function call."""

[[exercises]]
name = "macros2"
dir = "21_macros"
test = false
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
dir = "21_macros"
test = false
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent."""

[[exercises]]
name = "macros4"
dir = "21_macros"
test = false
hint = """
You only need to add a single character to make this compile.

The way macros are written, it wants to see something between each "macro arm",
so it can separate them.

That's all the macro exercises we have in here, but it's barely even scratching
the surface of what you can do with Rust's macros. For a more thorough
introduction, you can have a read through 'The Little Book of Rust Macros':
https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Rust stores the highest precision version of some long or infinite precision
mathematical constants in the Rust standard library:
https://doc.rust-lang.org/stable/std/f32/consts/index.html

We may be tempted to use our own approximations for certain mathematical
constants, but clippy recognizes those imprecise mathematical constants as a
source of potential error.

See the suggestions of the Clippy warning in the compile output and use the
appropriate replacement constant from `std::f32::consts`."""

[[exercises]]
name = "clippy2"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
`for` loops over `Option` values are more clearly expressed as an `if-let`
statement.

Not required to solve this exercise, but if you are interested in when iterating
over `Option` can be useful, read the following section in the documentation:
https://doc.rust-lang.org/std/option/#iterating-over-option"""

[[exercises]]
name = "clippy3"
dir = "22_clippy"
test = false
strict_clippy = true
hint = "No hints this time!"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
dir = "23_conversions"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
dir = "23_conversions"
hint = """
Follow the steps provided right before the `From` implementation."""

[[exercises]]
name = "from_str"
dir = "23_conversions"
hint = """
The implementation of `FromStr` should return an `Ok` with a `Person` object,
or an `Err` with an error if the string is not valid.

This is almost like the previous `from_into` exercise, but returning errors
instead of falling back to a default value.

Another hint: You can use the `map_err` method of `Result` with a function or a
closure to wrap the error from `parse::<u8>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "try_from_into"
dir = "23_conversions"
hint = """
Is there an implementation of `TryFrom` in the standard library that can both do
the required integer conversion and check the range of the input?

Challenge: Can you make the `TryFrom` implementations generic over many integer
types?"""

[[exercises]]
name = "as_ref_mut"
dir = "23_conversions"
hint = """
Add `AsRef<str>` or `AsMut<u32>` as a trait bound to the functions."""
